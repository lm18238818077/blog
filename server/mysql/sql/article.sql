INSERT INTO `article` VALUES (2, '前端想要了解的Nginx', '> Nginx 是一个高性能的HTTP和反向代理服务器，同时也是一个 IMAP/POP3/SMTP 代理服务器。\n> \n\n##  常见场景：\n* 静态资源服务器\n* 动态匹配\n* 反向代理\n* Gzip 压缩\n* 负载均衡', 12, '2020-1-28 20:24:04', '2020-9-23 14:39:13');
INSERT INTO `article` VALUES (3, '前端项目部署到阿里云服务器', '# 前言\n本文讲解的是：做为前端开发人员，对服务器的了解还是小白的我，是如何一步步将 node+mysql 项目部署在阿里云 centos 7.3 的服务器上，搭建的项目是采用了主流的前后端分离思想的，这里只讲 服务器环境搭建。\n## 1. 流程\n1. 开发好前端与后端程序。\n2. 购买服务器与域名\n3. 服务器上安装所需环境（本项目是 node 和 mysql ）\n4. 服务器上开放端口与设置规则\n5. 用 nginx、apache 或者tomcat 来提供HTTP服务或者设置代理\n6. 上传项目代码 或者 用码云或者 gihub 来拉取你的代码到服务器上\n7. 启动 koa 服务器\n## 2. 内容细节\n### 2.1 开发好前端与后端程序\n开发好前端与后端程序，这个没什么好说的，就是开发！开发！开发！再开发！\n### 2.2 购买服务器与域名\n本人一直觉得程序员应该有一个自己的个人网站，拥有自己的域名与服务器。学知识或者测试项目的时候可以用来测试。\n阿里云有个专供学生的云翼计划 阿里云学生套餐，入门级的云服务器原价1400多，学生认证后只要114一年，非常划算。\n还是学生的，直接购买；不是学生了，有弟弟、妹妹的，可以用他们的大学生身份，购买，非常便宜实用（我购买的就是学生优惠套餐）。当然阿里云服务器在每年双 11 时都有很大优惠，也很便宜，选什么配置与价格得看自己的用处。\n服务器预装环境可以选择 CentOS 或者 windows server，，为了体验和学习 linux 系统，我选择了CentOS。\n当然如果你的网站只用来自己用的话，可以不用买域名，因为可以通过服务器的公网 ip 来访问网站内容的。\n如果购买了域名了，还要设置域名映射到相应的公网 ip ，不然也不能用。\n## 3. 服务器上安装所需环境（本项目是 node 和 mysql ）\n### 3.1 登录服务器\n 通过下面的命令行连接到服务器。root 是阿里云服务器默认的账号名，连接时候会叫你输入密码，输入你购买时设置的或者后来设置的密码。\n ```ssh root@47.104.192.184   //你的服务器公网 ip，比如47.104.192.184```\n 也可以参考文章[Node.js 项目部署到阿里云服务器（CentOs）](https://segmentfault.com/a/1190000004051670)\n 一般在新服务器创建后，建议先升级一下 CentOS：\n ```yum -y update```\n 常用的 Linux 命令\n ```cd 进入目录\ncd .. 返回上一个目录\nls -a 查看当前目录\nmkdir abc 创建abc文件夹\nmv 移动或重命名\nrm 删除一个文件或者目录\n```\n### 3.2 安装 node\n升级常用库文件, 安装 node.js 需要通过 g++ 进行编译。\n ```yum -y install gcc gcc-c++ autoconf```\n 跳转到目录：/usr/local/src，这个文件夹通常用来存放软件源代码：\n ```cd /usr/local/src```\n下载安装包\n ```wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-4.0.4.tgz```\n 下载完成后解压：\n ```tar -xzvf node-v10.13.0.tar.gz```\n 进入解压后的文件夹：\n``` cd node-v10.13.0```\n 执行配置脚本来进行预编译处理：\n ```./configure```\n 编译源代码，这个步骤花的时间会很长，大概需要 5 到 10 分钟：\n ```make```\n 编译完成后，执行安装命令，使之在系统范围内可用：\n ```make install```\n 建立超级链接, 不然 node 时会报 \"command not found\"\n ```sudo ln -s /usr/local/bin/node /usr/bin/node\nsudo ln -s /usr/local/lib/node /usr/lib/node\nsudo ln -s /usr/local/bin/npm /usr/bin/npm\nsudo ln -s /usr/local/bin/node-waf /usr/bin/node-waf\n```\n通过指令查看 node 及 npm 版本：\n```node -v```\n```npm -v```\nnode.js 到这里就基本安装完成了。\n### 3.3 安装 mysql\n确保服务器系统处于最新状态（这步操作可有可无）\n```[root@localhost ~]# yum -y update```\n首先检查是否已经安装，如果已经安装先删除以前版本，以免安装不成功\n```rpm -qa | grep mysql```\n或\n```yum list installed | grep mysql```\n如果安装了的话，就使用下面这条命令删除原先的mysql,举例如下：\n```rpm -e  --nodeps        mysql-libs-5.1.73-5.e16_6.i686  ```\n下载MySql安装包\n```rpm -ivh http://dev.mysql.com/get/mysql57-community-release-el7-8.noarch.rpm```\n 安装MySql\n ```yum install -y mysql-server```\n 如果显示以下内容说明安装成功\n```Complete!```\n 设置开机启动mysql\n ```systemctl enable mysqld.service```\n 检查是否已经安装了开机自动启动\n ```systemctl list-unit-files | grep mysqld```\n 如果显示以下内容说明已经完成自动启动安装\n```mysqld.service enabled```\n设置开启服务\n```systemctl start mysqld.service```\n查看MySql默认密码\n```grep \'temporary password\' /var/log/mysqld.log ```\n登陆MySql，输入用户名和密码\n```mysql -uroot -p       //密码也就是第九步里面查看到的默认密码```\n修改当前用户密码 注意看下面的报错\n```mysql>SET PASSWORD = PASSWORD(\'alliance\');  //但是这样会报错的，具体错误看下面```\n注：直接复制粘贴上边的命令，会报错，错误如下\n>  your password does not satisfy the current  policy requirements\n\n解决方案如下：\n原因：mysql为了安全，有自己的策略要求，如果我们想将其设置为我们常用的root或者123456这样的密码，需要修改策略要求，具体命令如下：\n```set global validate_password_policy=LOW```\n进行设值\n然后再次在mysql命令行下执行\n```SET PASSWORD = PASSWORD(\'新密码\'); ```\n成功！\n开启远程登录，授权root远程登录（解释：不要以为阿里云服务器可以远程登录root用户，就以为我们也可以以mysql的root用户身份远程登录mysql数据库）\n```GRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'lm123456\' WITH GRANT OPTION;   //这里的lm123456要换成你自己mysql数据库的密码```\n```flush privileges; // 这一步一定要做，不然无法成功！ 这句表示从mysql数据库的grant表中重新加载权限数， 因为MySQL把权限都放在了cache中，所以在做完更改后需要重新加载。```\n### 3.4 服务器上开放端口与设置安全组规则\n>如果你只放静态的网页，可以参考这个篇文章 [通过云虚拟主机控制台设置默认首页](https://help.aliyun.com/knowledge_detail/36154.html)\n>\n授权安全组规则可以允许或者禁止与安全组相关联的 ECS 实例的公网和内网的入方向和出方向的访问。 \n\n\n比如我们的服务要用到 3000 ，就要开放 3000 的端口，不然是访问不了的；其他端口同理\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/1580623553.jpg)\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/1580623798.jpg)\n### 3.5 用 nginx、apache 或者 tomcat 来提供 HTTP 服务或者设置代理\n我是用了 nginx 的，所以这里只介绍 nginx 。 安装 nginx 请看这两篇文章：\n>[Centos7安装Nginx实战](https://cloud.tencent.com/developer/news/119838)\n>[阿里云Centos7安装Nginx服务器实现反向代理](https://blog.csdn.net/qq_21508727/article/details/80071174)\n>\n\n开启 ngnx 代理\n* 进入到目录位置\n```cd /usr/local/nginx```\n* 在 nginx 目录下有一个 sbin 目录，sbin 目录下有一个 nginx 可执行程序。\n```./nginx```\n关闭 nginx\n```./nginx -s stop```\n重启\n```./nginx -s reload```\n* 如下给出我的 nginx 代理的设置：\n我的两个项目是放在 /home/blog2/blog/build/下的，如果你们的路径不是这个，请修改成你们的路径。\n```#user  nobody;\nworker_processes  1;\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n#pid        logs/nginx.pid;\nevents {\n    worker_connections  1024;\n}\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n    #                  \'$status $body_bytes_sent \"$http_referer\" \'\n    #                  \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n    #access_log  logs/access.log  main;\n    sendfile        on;\n    #tcp_nopush     on;\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n    #gzip  on;\n    # 如果port_in_redirect为off时，那么始终按照默认的80端口；如果该指令打开，那么将会返回当前正在监听的端口。\n    port_in_redirect off;\n\n    # 前台展示打开的服务代理\n    server {\n        listen       80;\n        server_name  localhost;\n        #charset koi8-r;\n        #access_log  logs/host.access.log  main;\n        #root /home/blog;\n        location  / {\n            root   /home/blog/blog-react/build/;\n            index  index.html;\n            try_files $uri $uri/ @router;\n            autoindex on;\n        }\n        location @router{\n            rewrite ^.*$ /index.html last;\n        }\n        location /api/ {\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_pass http://47.106.136.114:3000/ ;\n        }\n        gzip on;\n        gzip_buffers 32 4k;\n        gzip_comp_level 6;\n        gzip_min_length 200;\n        gzip_types text/css text/xml application/javascript;\n        gzip_vary on;\n        #error_page  404              /404.html;\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n\n    # HTTPS server\n    # 管理后台打开的服务代理\n    server {\n        listen       4444;\n        server_name  localhost;\n        #   charset koi8-r;\n        #   ssl_certificate      cert.pem;\n        #   ssl_certificate_key  cert.key;\n        #   ssl_session_cache    shared:SSL:1m;\n        #    ssl_session_timeout  5m;\n        #    ssl_ciphers  HIGH:!aNULL:!MD5;\n        #    ssl_prefer_server_ciphers  on;\n        location / {\n            root   /home/blog/blog-react-admin/dist/;\n            index  index.html index.htm;\n            try_files $uri $uri/ @router;\n            autoindex on;\n        }\n        location @router{\n            rewrite ^.*$ /index.html last;\n        }\n\n        location /api/ {\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_pass http://47.106.136.114:3000/ ;\n        }\n        gzip on;\n        gzip_buffers 32 4k;\n        gzip_comp_level 6;\n        gzip_min_length 200;\n        gzip_types text/css text/xml application/javascript;\n        gzip_vary on;\n        error_page   500 502 503 504  /50x.html;\n    }\n}\n```\n\n### 3.6 上传项目代码，或者用码云、 gihub 来拉取你的代码到服务器上\n### 3.7 启动 koa 服务\n启动 express 服务，我用了 pm2， 可以永久运行在服务器上，且不会一报错 express 服务就挂了，而且运行中还可以进行其他操作。\n安装：\n```npm install -g pm2```\n```pm2 start 文件名```\n比如我操作项目时的基本操作：\n```pm2 start     // 开启\npm2 stop       // 关闭\npm2 list    //查看所用已启动项目```', 34, '2020-2-2 14:49:16', '2020-12-11 11:22:55');
INSERT INTO `article` VALUES (4, 'GitHub Actions 入门教程', '## 一、GitHub Actions 是什么？\n大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。\n\n很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。\n\n如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。\n\nGitHub 做了一个[官方市场](https://github.com/marketplace?type=actions)，可以搜索到他人提交的 actions。另外，还有一个 [awesome actions ](https://github.com/sdras/awesome-actions)的仓库，也可以找到不少 action。\n\n上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName/repoName的语法引用 action。比如，actions/setup-node就表示github.com/actions/setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com/actions 里面。\n\n既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。\n\n```\nactions/setup-node@74bc508 # 指向一个 commit\nactions/setup-node@v1.0    # 指向一个标签\nactions/setup-node@master  # 指向一个分支\n```\n## 二、基本概念\nGitHub Actions 有一些自己的术语。\n\n1. workflow （工作流程）：持续集成一次运行的过程，就是一个 workflow。\n\n2. job （任务）：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。\n\n3. step（步骤）：每个 job 由多个 step 构成，一步步完成。\n\n4. action （动作）：每个 step 可以依次执行一个或多个命令（action）。\n\n## 三、workflow 文件\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\nworkflow 文件的配置字段非常多，详见[官方文档](https://help.github.com/en/articles/workflow-syntax-for-github-actions)。下面是一些基本字段。\n1.   ```name ```\n		name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。\n> 		 name: GitHub Actions Demo		 \n\n2.   ```on ```\n	 on字段指定触发 workflow 的条件，通常是某些事件。\n> 	 on: push\n\n上面代码指定，push事件触发 workflow。\non字段也可以是事件的数组。\n> on: [push, pull_request]\n\n上面代码指定，push事件或pull_request事件都可以触发 workflow。\n完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。\n\n3.  ```on.<push|pull_request>.<tags|branches> ```\n  指定触发事件时，可以限定分支或标签。\n	>\n 	on:\n    push:\n      branches:    \n		    - master\n\n\n上面代码指定，只有master分支发生push事件时，才会触发 workflow。\n\n4.  ``` jobs.<job_id>.name```\n   workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。\n	jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。\n> 	jobs:\n		 my_first_job:\n				name: My first job\n		 my_second_job:\n				 name: My second job\n    \n	上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。\n\n5.  ``` jobs.<job_id>.needs ```\n	needs字段指定当前任务的依赖关系，即运行顺序。\n> 	jobs:\n			 job1:\n			 job2:\n				 needs: job1\n			 job3:\n				needs: [job1, job2]\n     \n\n上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。\n\n6.  ```jobs.<job_id>.runs-on ```\n	runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。\n> ubuntu-latest，ubuntu-18.04或ubuntu-16.04\n> windows-latest，windows-2019或windows-2016\n> macOS-latest或macOS-10.14\n\n下面代码指定虚拟机环境为ubuntu-18.04。\n> runs-on: ubuntu-18.04\n\n7. ```jobs.<job_id>.steps```\nsteps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。\n> jobs.<job_id>.steps.name：步骤名称。\n> jobs.<job_id>.steps.run：该步骤运行的命令或者 action。\n> jobs.<job_id>.steps.env：该步骤所需的环境变量。\n\n下面是一个完整的 workflow 文件的范例。\n```\nname: Node CI\non:\n  push:\n    branches:\n      - master       //整个流程在master分支发生push事件时触发。\njobs:\n  build:\n    runs-on: ubuntu-latest          //只有一个job，运行在虚拟机环境ubuntu-latest。\n    strategy:\n      matrix:\n        node-version: [12.x]\n\n    steps:\n    - uses: actions/checkout@v1          //第一步是获取源码，这是github官方的一个action，用于clone该仓库的源码到工作流中。\n    - name: Use Node.js 12.x\n		\n      uses: actions/setup-node@v1\n      with:\n        node-version: 12.x\n    - name: npm install, build\n      run: |\n        npm install\n        npm run build --if-present\n      env:\n        CI: true\n    # 设置阿里云OSS的 id/secret，存储到 github 的 secrets 中\n    - name: setup aliyun oss\n      uses: manyuanrong/setup-ossutil@master\n      with:\n        endpoint: oss-cn-beijing.aliyuncs.com\n        access-key-id: ${{ secrets.OSS_KEY_ID }}\n        access-key-secret: ${{ secrets.OSS_KEY_SECRET }}\n    #- name: 删除冗余文件\n      #run: ossutil rm  oss://f6-ming/react-blog/build -rf\n    - name: 复制文件到阿里云OSS\n      run: ossutil cp -rf build oss://f6-ming/react-blog/\n\n```\n上面这个 workflow 文件的要点如下。\n1. 整个流程在master分支发生push事件时触发。\n2. 只有一个job，运行在虚拟机环境ubuntu-latest。\n3. 第一步是获取源码，使用的 action 是actions/checkout。\n4. 第二步是构建，使用的 action 是  setup-node\n5. 第三步使用的 action 是manyuanrong/setup-ossutil，将build文件复制到oss\n				\n\n\n\n\n', 23, '2020-2-5 15:04:09', '2020-7-5 22:54:14');
INSERT INTO `article` VALUES (5, 'umi-hooks分享', '## Umi Hooks - 助力拥抱 React Hooks\nReact Hooks 是 react v16.8 的一个新特性，很佩服这么重磅的功能，在一个小版本中发布，说明 React 团队有足够的信心向上兼容。\n\n为什么要放弃 Class，转用 Hooks 呢？在内部外部有很多争论，包括知乎也有类似提问。我们也不免俗套的要对比下 Class 和 Hooks 了。\n![](https://pic3.zhimg.com/80/v2-2fd987342f118ea9f3a154842bbe1d16_hd.jpg)\n### Class 学习成本高\n\nClass 学习成本很高。首当其中的就是生命周期，多，太多了。不仅多，还会变！React v15 和 v16 就不一样。下面是我在网上随便找的一张图。\n![](https://pic2.zhimg.com/80/v2-69a3b2dbe64a5575d46ff6541690c629_hd.jpg)\n这个是 React v15 的生命周期，你都掌握了吗？你知道 v16 有什么变化吗？\n之前无论你去哪里面试，基本都会有几个必问问题：\n\n1. 讲讲 React 生命周期？React v15 和 React v16 生命周期有啥变化？\n2. 如何优化 Class 组件？shouldComponentUpdate 是做什么的？如何用？\n3. 一般在哪个生命周期发送网络请求？为什么？\n......\n\n生命周期最重要，但是有很高的学习成本，需要大量实践才能积累足够的经验。当然，这几个问题回答不好，百分之八十以上的几率会挂掉。\n当然不止是生命周期，this 也是一个很大的问题。你有没有在组件写很多 bind？或者所有的函数都用箭头函数定义？\n\nthis.someFunction = this.someFunction.bind(this);\n// 或\nsomeFunction = ()=>{}\n\n### Hooks 学习成本低\n对比 Class，Hooks 的学习成本可就太低了！掌握了 useState 和 useEffect，80% 的事情就搞定了。\n\nClass 业务逻辑分散\nClass 业务逻辑分散，实现一个功能，我要写在不同的生命周期里面，不聚合~\n比如，如果你有个定时器，你一定要在 componentWillUnMount 去卸载。\n\n接下来，我会用一个例子，比较一下class，hooks，umi-hooks\n![](https://pic2.zhimg.com/80/v2-6b6d3b6f506b7e7448ad119ea7a44165_hd.jpg)\n就是最简单的发起网络请求的组件。我们先用 Class 来实现看看\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15814764111064.png)\n\nreact-hooks写法\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15814764638865.png)\n\numi-hooks写法\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15814764865006.png)\n\n### Umi Hooks\n![](https://pic2.zhimg.com/80/v2-970f0e0f184df5292a42b0fc662a51bd_hd.jpg)\n[ Umi Hooks](https://hooks.umijs.org/zh-CN/)\n\n\n#### useRequest\n比如维护 page 、 pageSize 、 sorter 、 filter 的状态，还得考虑搜索条件变化后，重置 page 到第一页。这些逻辑光想想就头疼了，别说写了。\n现在一行代码就可以实现了！useAntdTable(已废弃)，封装了所有的逻辑，你只要 ...tableProps，就可以了。这也许就是幸福的味道吧~\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_15814778721488.png)\n\n\n\n[参考链接](https://zhuanlan.zhihu.com/p/103150605)', 17, '2020-2-9 16:29:07', '2020-9-23 14:36:38');
INSERT INTO `article` VALUES (6, 'docker', '#docker常用命令\r\n\r\n\r\n\r\n```\r\n#关闭\r\ndocker stop mycentos\r\n\r\n#重启\r\ndocker start mycentos\r\n\r\n#退出\r\nexit \r\n```\r\n\r\n```javascript\r\ndocker run -d  -p 8000:80 10.10.50.4/xianzhi/lms-pc-web:65\r\n           后台运行       宿主端口：容器端口 镜像名称：版本\r\ndocker commit --author \"lm18238818077\" --message \"curl+node\" 552df3cfed24 lm18238818077/myworkspace:v1   //创建镜像（根据基础镜像）\r\ndocker run -it --name lmnewWorkSpace lm18238818077/myworkspace:v1 /bin/bash\r\n```\r\n\r\n```\r\ndocker exec -it 53279f03870 /bin/bash\r\n进入容器          容器id \r\n```\r\n\r\n```\r\ndocker inspect 容器名称或 id\r\ndocker查看容器IP地址\r\n```\r\n\r\n```\r\ndocker ps 查看容器\r\n -a :显示所有的容器，包括未运行的。\r\n```\r\n\r\n```javascript\r\ndocker rmi 75835a67d134  //删除镜像\r\ndocker rm 75835a67d134  //删除容器\r\n```\r\n\r\n```javascript\r\ndocker commit --author \"账号名字\" --message \"curl+node\" 9298 rccoder/myworkspace:v1 \r\n												\r\n```\r\n\r\n## lmspc 部署流程\r\n\r\n1.build （master  npm run pro）\r\n2.dist->f3\r\n3.docker build\r\n4.docker push(docker login)\r\n5.wayne    [发布新版本](http://wayne.cluster.dfwsgroup.com/public/portal/namespace/12/app/25/deployment/84)\r\n\r\n```shell\r\n\r\ndocker build -t docker-registry.cluster.dfwsgroup.cn/xianzhi/lms-pc-web:v1.0.2 -f deployment/docker/Dockerfile ./\r\n\r\n```\r\n\r\n\r\n\r\n> https://juejin.im/post/5ad3172c5188257ddb10109a\r\n\r\n\r\n\r\n# vi命令\r\n\r\n* :q!   若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\r\n* :q  离开 vi (常用)\r\n* :w   将编辑的数据写入硬盘档案中(常用)\r\n* :wq      储存后离开，若为 :wq! 则为强制储存后离开 (常用)\r\n* :x   退出编辑器，如果文件有改动，则保存再退出\r\n\r\n', 4, '2020-2-12 19:21:30', '2020-7-6 09:13:33');
INSERT INTO `article` VALUES (7, 'ts', '#函数的类型\r\n\r\n##1.函数表达式\r\n\r\n* 在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\r\n\r\n```javascript\r\nlet mySum: (x: number, y: number) => number = function (x: number, y: number): number {\r\n    return x + y;\r\n};\r\n```\r\n\r\n## 2.可选参数\r\n\r\n* 我们用 `?` 表示可选的参数，可选参数后面不允许再出现必须参数了\r\n\r\n  ```javascript\r\n  function buildName(firstName: string, lastName?: string) {\r\n      if (lastName) {\r\n          return firstName + \' \' + lastName;\r\n      } else {\r\n          return firstName;\r\n      }\r\n  }\r\n  let tomcat = buildName(\'Tom\', \'Cat\');\r\n  let tom = buildName(\'Tom\');\r\n  ```\r\n\r\n  \r\n\r\n#1.基础类型\r\n\r\n- ## 布尔值\r\n\r\n  ```javascript\r\n  let isDone: boolean = false;\r\n  ```\r\n\r\n  \r\n\r\n- ## 数字\r\n\r\n  ```javascript\r\n  let decLiteral: number = 6;\r\n  let hexLiteral: number = 0xf00d;\r\n  let binaryLiteral: number = 0b1010;\r\n  let octalLiteral: number = 0o744;\r\n  ```\r\n\r\n  \r\n\r\n- ## 字符串\r\n\r\n  ```javascript\r\n  let name: string = \"bob\";\r\n  name = \"smith\";\r\n  let sentence: string = `Hello, my name is ${ name }.\r\n  ```\r\n\r\n- ## 数组\r\n\r\n  1. ```\r\n     let list: number[] = [1, 2, 3];\r\n     ```\r\n\r\n  2. ```jade\r\n     let list: Array<number> = [1, 2, 3];\r\n     ```\r\n\r\n     \r\n\r\n- ## 元组 Tuple\r\n\r\n  元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为`string`和`number`类型的元组。\r\n\r\n  ```javascript\r\n  // Declare a tuple type\r\n  let x: [string, number];\r\n  // Initialize it\r\n  x = [\'hello\', 10]; // OK\r\n  // Initialize it incorrectly\r\n  x = [10, \'hello\']; // Error\r\n  ```\r\n\r\n- ## 枚举\r\n\r\n  `enum`类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。\r\n\r\n   ``` javascript\r\n  enum Color {Red, Green, Blue}\r\n  let c: Color = Color.Green;\r\n   ```\r\n\r\n- ## Any \r\n\r\n  有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 `any`类型来标记这些变量：\r\n\r\n  ``` javascript\r\n  let notSure: any = 4;\r\n  notSure = \"maybe a string instead\";\r\n  notSure = false; // okay, definitely a boolean\r\n  \r\n  let list: any[] = [1, true, \"free\"];\r\n  list[1] = 100;\r\n  ```\r\n\r\n- ## Void\r\n\r\n  某种程度上来说，`void`类型像是与`any`类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 `void`：\r\n\r\n  ``` javascript\r\n  function warnUser(): void {\r\n      console.log(\"This is my warning message\");\r\n  }\r\n  ```\r\n\r\n- ## Null 和 Undefined\r\n\r\n  ``` javascript\r\n  // Not much else we can assign to these variables!\r\n  let u: undefined = undefined;\r\n  let n: null = null;\r\n  ```\r\n\r\n- ## Never\r\n\r\n  `never`类型表示的是那些永不存在的值的类型。 例如， `never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 `never`类型，当它们被永不为真的类型保护所约束时。 \r\n\r\n  ``` javascript\r\n  // 返回never的函数必须存在无法达到的终点\r\n  function error(message: string): never {\r\n      throw new Error(message);\r\n  }\r\n  \r\n  // 推断的返回值类型为never\r\n  function fail() {\r\n      return error(\"Something failed\");\r\n  }\r\n  \r\n  // 返回never的函数必须存在无法达到的终点\r\n  function infiniteLoop(): never {\r\n      while (true) {\r\n      }\r\n  }\r\n  ```\r\n\r\n- ## Object\r\n\r\n  `object`表示非原始类型，也就是除`number`，`string`，`boolean`，`symbol`，`null`或`undefined`之外的类型。\r\n\r\n  使用`object`类型，就可以更好的表示像`Object.create`这样的API。例如：\r\n\r\n  ```javascript\r\n  declare function create(o: object | null): void;\r\n  \r\n  create({ prop: 0 }); // OK\r\n  create(null); // OK\r\n  \r\n  create(42); // Error\r\n  create(\"string\"); // Error\r\n  create(false); // Error\r\n  create(undefined); // Error\r\n  ```\r\n\r\n  \r\n\r\n# 2.变量声明\r\n\r\n- ## 变量声明\r\n\r\n  `let`和`const`是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， `let`在很多方面与`var`是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 `const`是对`let`的一个增强，它能阻止对一个变量再次赋值。\r\n\r\n  因为TypeScript是JavaScript的超集，所以它本身就支持`let`和`const`。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\r\n\r\n   # 3.接口\r\n\r\n - ## 介绍\r\n\r\n   TypeScript的核心原则之一是对值所具有的*结构*进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。\r\n\r\n- ## 可选属性 \r\n\r\n  接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。\r\n\r\n``` javascript\r\n//可选属性\r\n\r\ninterface SquareConfig {\r\n  color?: string;\r\n  width?: number;\r\n}\r\n\r\nfunction createSquare(config: SquareConfig): {color: string; area: number} {\r\n  let newSquare = {color: \"white\", area: 100};\r\n  if (config.color) {\r\n    newSquare.color = config.color;\r\n  }\r\n  if (config.width) {\r\n    newSquare.area = config.width * config.width;\r\n  }\r\n  return newSquare;\r\n}\r\n\r\nlet mySquare = createSquare({color: \"black\"});\r\n\r\n```\r\n\r\n- ## 只读属性 \r\n\r\n  一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly`来指定只读属性:\r\n\r\n  ``` javascript\r\n  interface Point {\r\n      readonly x: number;\r\n      readonly y: number;\r\n  }\r\n  \r\n  //另一种写发放\r\n  let a: number[] = [1, 2, 3, 4];\r\n  let ro: ReadonlyArray<number> = a;\r\n  ```\r\n\r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n', 6, '2020-2-12 19:22:37', '2020-7-5 22:54:23');
INSERT INTO `article` VALUES (8, 'umi-library（father） 做组件打包', '# 利用 umi-library（father） 做组件打包。\n>本文的目标是带你开发一个组件库，并走通开发、测试、文档、打包还有发布流程。\n[参考链接](https://github.com/clock157/blog/issues/1)\n\n## Features\n\n* ✔︎ 基于 [docz](https://www.docz.site/) 的文档功能\n* ✔︎ 基于 [rollup](http://rollupjs.org/) 和 babel 的组件打包功能\n* ✔︎ 支持 TypeScript\n* ✔︎ 支持 cjs、esm 和 umd 三种格式的打包\n* ✔︎ esm 支持生成 mjs，直接为浏览器使用\n* ✔︎ 支持用 babel 或 rollup 打包 cjs 和 esm\n* ✔︎ 支持多 entry\n* ✔︎ 支持 lerna\n* ✔︎ 支持 css 和 less，支持开启 css modules\n* ✔︎ 支持 test\n* ✔︎ 支持用 prettier 和 eslint 做 pre-commit 检查\n\n## 准备环境\n> 创建目录\nmkdir umi-library-demo && cd     umi-library-demo\n初始化\nyarn create umi --library\n安装依赖\n yarn\nyarn run dev\n浏览器访问 http://127.0.0.1:8001/  即可看到我们的组件开发环境。\n\n## 组件打包\n\n组件开发测试完成后，需要打包成不同的产物以适应不同的场景。默认使用 `rollup` 打包生成三个格式的包:\n\n- cjs: CommonJs，es5,能被 Node 和 打包工具如 webpack 使用。\n- esm: ES Module，es6,支持静态分析可以 tree shaking。\n- umd: Universal Module Definition 通用包，既能像 cjs 一样被使用，也可以发布到 cdn，通过 script 的方式被浏览器使用。\n\n## 发布组件\n```\n  \"name\": \"light-toast-lm\",\n  \"version\": \"0.0.3\",\n  \"description\": \"轻量级提示\",\n  \"main\": \"dist/index.js\",\n  \"module\": \"dist/index.esm.js\",\n  \"unpkg\": \"dist/index.umd.js\",\n  \"files\": [\n    \"dist\"\n  ],\n  ```\nyarn publish\n\n##发布组件文档\n使用命令\n基于 mdx，你可以使用 markdown 加 jsx 语法来组织文档。\n\nyarn doc:build \nyarn doc:deploy 发布组件文档\n\numi-library 默认将文档部署到`github.io`, url 规则是 https://{yourname}.github.io/{your-repo}，我们需要修改 .fatherrc.js 配置一下文档静态资源的前缀base。\n\n\n\n\n\n## LICENSE\n\nMIT\n', 4, '2020-6-11 16:33:32', '2020-9-23 14:39:31');
INSERT INTO `article` VALUES (9, 'JavaScript深入之从原型到原型链 ', '## 真的是继承吗？\n最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：\n继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/prototype5.png)\n\n## 什么是原型\n你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性\n\n## __proto__\n这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。\n\n```\nfunction Person() {\n\n}\n\nvar person = new Person();\n\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n// 顺便学习一个ES5的方法,可以获得对象的原型\nconsole.log(Object.getPrototypeOf(person) === Person.prototype) // true\n```\n\n', 14, '2020-6-18 10:52:37', '2020-9-16 14:47:49');
INSERT INTO `article` VALUES (10, 'JavaScript深入之词法作用域和动态作用域', '## 作用域\n作用域是指程序源代码中定义变量的区域。\n作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。\nJavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。\n函数的作用域在函数定义的时候就决定了\n', 0, '2020-7-6 17:32:46', '2020-7-6 17:34:43');
INSERT INTO `article` VALUES (11, 'JavaScript深入之call和apply的模拟实现', '## call\n总体实现思路\nvar foo = {\n    value: 1,\n    bar: function() {\n        console.log(this.value)\n    }\n};\nfoo.bar(); // 1\n\n- 将函数设为对象的属性\n- 执行该函数\n- 删除该函数\n\n```\nFunction.prototype.mycall = function(context){\n	context = context || window\n	context.fn = this   //将调用call的函数转到对象的属性上\n	let args = [].slice.call(arguments,1)\n	let result = context.fn(...args)\n	delete context.fn\n	return  result\n}\n```', 15, '2020-7-7 17:32:22', '2020-10-3 00:16:37');
INSERT INTO `article` VALUES (12, 'JavaScript深入之new的模拟实现', '```\nfunction objectFactory() {\n	var obj = {}\n	var con = [].shift.apply(arguments)\n	obj._proto_ = con.prototype\n	var ret = con.apply(obj,arguments)\n	\n	return typeof ret === \'object\' ? ret : obj;  //确保构造器总是返回一个对象\n};\n```\n1. 用new Object() 的方式新建了一个对象 obj\n2. 取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数\n3. 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性\n4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性\n5. 返回 obj\n\n\n\n', 10, '2020-7-8 17:58:36', '2020-11-2 11:51:33');
INSERT INTO `article` VALUES (13, '事件捕获和事件冒泡', ' ## 事件冒泡\n也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。\n\n## 事件捕获\n与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。\n\n\n来 w3c 采用折中的方式，平息了战火，制定了统一的标准——先捕获再冒泡。\naddEventListener的第三个参数就是为冒泡和捕获准备的.\naddEventListener有三个参数：\n\nelement.addEventListener(event, function, useCapture)\n\n第一个参数是需要绑定的事件\n第二个参数是触发事件后要执行的函数\n第三个参数默认值是false，表示在事件冒泡阶段调用事件处理函数;\n如果参数为true，则表示在事件捕获阶段调用处理函数。\n\n在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，\n对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。\n\n\n哪些事件不支持冒泡事件：鼠标事件：mouserleave  mouseenter\n焦点事件：blur focus\nUI事件：scroll resize\n', 5, '2020-7-27 11:16:19', '2020-10-4 03:37:51');
INSERT INTO `article` VALUES (14, 'debounce', '> 防抖的原理就是：你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行，总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行，真是任性呐!\n```\nfunctin debounce(func, wait){\n	var timeout ;\n	return function(){\n		var context = this\n		var args = arguments\n		if (timeout) clearTimeout(timeout);\n		timeout = setTimeout(function(){\n			func.apply(context,args)\n		},wait)\n	}\n}', 1, '2020-8-10 18:02:26', '2020-8-21 14:42:14');
INSERT INTO `article` VALUES (15, 'throttle', '> 节流的原理很简单：如果你持续触发事件，每隔一段时间，只执行一次事件。\n```\nfunction throttle(func,wait){\n	var context = this,previous=0,args;\n	return function(){\n	var now = + new Date()\n		if(now - previous > wait){\n		func.apply(context,args)\n		previous = now\n	}\n\n}', 2, '2020-8-10 18:16:33', '2020-10-3 11:26:07');
INSERT INTO `article` VALUES (16, 'React架构', '## React15架构\nReconciler（协调器）—— 负责找出变化的组件\nRenderer（渲染器）—— 负责将变化的组件渲染到页面上\n\n### Reconciler（协调器）\n每当有更新发生时，Reconciler会做如下工作：\n* 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM\n* 将虚拟DOM和上次更新时的虚拟DOM对比\n* 通过对比找出本次更新中变化的虚拟DOM\n* 通知Renderer将变化的虚拟DOM渲染到页面上\n\n### Renderer（渲染器）\nRenderer ——  ReactDOM\n在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。\n\n### 生命周期\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/react-component.webp)\n\n### 新版生命周期\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/react-component-new.webp)', 7, '2020-8-11 18:58:01', '2020-10-5 21:29:06');
INSERT INTO `article` VALUES (17, 'JavaScript深入之作用域链', '### 对于每个执行上下文，都有三个重要属性：\n* 变量对象(Variable object，VO)\n* 作用域链(Scope chain)\n* this\n> 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。\n> \n\n函数的作用域在函数定义的时候就决定了。\n这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！\n', 2, '2020-8-12 17:54:48', '2020-10-3 01:01:01');
INSERT INTO `article` VALUES (18, 'JavaScript 执行机制', '![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/15fdd88994142347.png)\n1. 同步和异步任务分别进入不同的执行\"场所\"，同步的进入主线程，异步的进入Event Table并注册函数。\n2. 当指定的事情完成时，Event Table会将这个函数移入Event Queue。\n3. 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。\n4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)。\n\n\n\n事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/15fdcea13361a1ec.png)\n\n### 最后\njavascript是一门单线程语言\nEvent Loop是javascript的执行机制\n', 3, '2020-8-15 09:27:34', '2020-10-3 01:19:14');
INSERT INTO `article` VALUES (19, '清除浮动', '### 总的思路\n1. 利用 clear属性，清除浮动\n2. 使父容器形成BFC（原理：计算BFC的高度时，浮动元素也参与计算）\n\n\n1. 给浮动元素的兄弟添加一个空div，然后添加样式css:{clear:both;height:0;overflow:hidden}\n2. 给浮动元素父级设置高度\n3. 父级同时浮动（需要给父级同级元素添加浮动）\n4. 父级设置成inline-block\n5. 给父级添加overflow:hidden 清除浮动方法\n6. 万能清除法 after伪类 清浮动（现在主流方法，推荐使用）\n\n```\nfloat_div:after{\ncontent:\".\";\nclear:both;\ndisplay:block;\nheight:0;\noverflow:hidden;\nvisibility:hidden;\n}\n.float_div{\nzoom:1\n}\n\n```\n\n### 触发BFC\nbfc定义\n按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如边框，非空内容，padding等)就会发生margin重叠。\n1. 根元素 body\n2. position: absolute/fixed\n3. display: inline-block / table\n4. float 非none\n5. ovevflow !== visible\n\n### BFC原则\n* 内部的Box会在垂直方向上一个接一个的放置\n* 垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠（塌陷），与方向无关。）\n* 每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）\n* BFC的区域不会与float的元素区域重叠（利用这个可以左中右布局）\n* 计算BFC的高度时，浮动子元素也参与计算（利用这个原则清楚浮动）\n* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n* 看到以上的几条约束，想想我们学习css时的几条规则\n* \n* Block元素会扩展到与父元素同宽，所以block元素会垂直排列\n* 垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会(此规则并不完全正确)\n* 浮动元素会尽量接近往左上方（或右上方）\n* 为父元素设置overflow：hidden或浮动父元素，则会包含浮动元素\n[BFC原则](https://github.com/zuopf769/notebook/blob/master/fe/BFC%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/README.md)', 3, '2020-8-16 17:23:53', '2020-10-3 00:34:09');
INSERT INTO `article` VALUES (20, 'Webpack原理', '### Webpack\n* JavaScript 的 模块打包工具 (module bundler)。通过分析模块之间的依赖，最终将所有模块打包成一份或者多份代码包 (bundler)，供 HTML 直接引用。实质上，Webpack 仅仅提供了 打包功能 和一套 文件处理机制，然后通过生态中的各种 Loader 和 Plugin 对代码进行预编译和打包。因此 Webpack 具有高度的可拓展性，能更好的发挥社区生态的力量。\n\n*  核心概念\n1. Entry: 入口文件，Webpack 会从该文件开始进行分析与编译；\n2. Output: 出口路径，打包后创建 bundler 的文件路径以及文件名；\n3. Module: 模块，在 Webpack 中任何文件都可以作为一个模块，会根据配置的不同的 Loader 进行加载和打包；\n4. Chunk: 代码块，可以根据配置，将所有模块代码合并成一个或多个代码块，以便按需加载，提高性能；\n5. Loader: 模块加载器，进行各种文件类型的加载与转换；\n6. Plugin: 拓展插件，可以通过 Webpack 相应的事件钩子，介入到打包过程中的任意环节，从而对代码按需修改；\n\n* 工作流程 (加载 - 编译 - 输出)\n1. 读取配置文件，按命令 初始化 配置参数，创建 Compiler 对象；\n2. 调用插件的 apply 方法 挂载插件 监听，然后从入口文件开始执行编译；\n3. 按文件类型，调用相应的 Loader 对模块进行 编译，并在合适的时机点触发对应的事件，调用 Plugin 执行，最后再根据模块 依赖查找 到所依赖的模块，递归执行第三步；\n4. 将编译后的所有代码包装成一个个代码块 (Chuck)， 并按依赖和配置确定 输出内容。这个步骤，仍然可以通过 Plugin 进行文件的修改;\n5. 最后，根据 Output 把文件内容一一写入到指定的文件夹中，完成整个过程；\n\n\n\n', 5, '2020-8-18 10:44:51', '2020-9-23 23:18:16');
INSERT INTO `article` VALUES (21, '观察者和发布者-订阅者模式的简单实现', '### 观察者模式\n```\nclass Observer {\n    constructor(label) {\n        this.label = label\n    }\n    update() {\n        console.log(`update${this.label}`)\n    }\n}\n\nclass Target {\n    constructor() {\n        this.observerList = []\n    }\n\n    add(observer) {\n        this.observerList.push(observer)\n    }\n\n    remove(observer) {\n        this.observerList = this.observerList.filter(ob => ob !== observer)\n    }\n\n    notify() {\n        this.observerList.forEach(ob => {\n            ob.update()\n        })\n    }\n}\n\nlet tar = new Target()\n\nfor (let i = 0; i < 10; i++) {\n    tar.add(new Observer(i))\n}\n\ntar.notify()//打印update1到update10\n```\n\n### 发布者-订阅者模式\n```\nclass Publisher {\n    constructor() {\n        this.subscribers = {}\n        this.cache = {}\n    }\n\n    add(type, fn) {\n        if (Object.prototype.toString.call(fn) !== \'[object Function]\') return\n        this.subscribers[type] ? this.subscribers[type].push(fn) : this.subscribers[type] = [fn]\n        return this\n    }\n\n    publish(type, theme) {\n        //存储主题信息\n        this.cache[type] ? this.cache[type].push(theme) : this.cache[type] = [theme]\n        let subscribers = this.subscribers[type]\n        if (!subscribers || !subscribers.length) {\n            console.warn(\'no subscriber in subscribers.\')\n            return this\n        }\n        subscribers.forEach(fn => fn.call(this, theme))\n        return this\n    }\n\n    unbind(type, fn) {\n        this.subscribers[type] = this.subscribers[type].filter(item => item !== fn)\n        return this\n    }\n\n    history(type, fn) {\n        let cache = this.cache[type] || []\n        cache.forEach(item => fn.call(this, item))\n        return this\n    }\n}\n\nlet sub1 = data => {\n    console.log(`sub1${data}`)\n}\n\nlet sub2 = data => {\n    console.log(`sub2${data}`)\n}\n\nlet sub3 = data => {\n    console.log(`sub3${data}`)\n}\n\nlet publisher = new Publisher()\n\npublisher.add(\'click\', sub1).add(\'click\', sub2).add(\'change\', sub3)\n\npublisher.publish(\'click\', \'第一次click\').publish(\'change\', \'第一次change\')\n\npublisher.unbind(\'click\', sub1).publish(\'click\', \'第二次点击\').history(\'click\', data => {\n    console.log(\'history\' + data)\n})\n\n打印结果：\n/***  \nsub1第一次click\nsub2第一次click\nsub3第一次change\nsub2第二次点击\nhistory第一次click\nhistory第二次点击\n***/\n```\n\n发布订阅者模式是一种一对多的依赖关系。多个对象（订阅者：subscriber）同时监听同一对象（发布者：publisher）的数据状态变化。\n\n```\nvar _Event=(function(){\n    var clienlist={},\n    addlisten,trigger,remove;\n    /**\n     * 增加订阅者\n     * @key {String} 类型\n     * @fn {Function} 回掉函数\n     * */\n    addlisten=function(key,fn){\n        if(!clienlist[key]){\n            clienlist[key]=[];\n        }\n        clienlist[key].push(fn);\n    };\n    /**\n     * 发布消息\n     * */\n    trigger=function(){\n        var key=[].shift.call(arguments),//取出消息类型\n            fns=clienlist[key];//取出该类型的对应的消息集合\n        if(!fns || fns.length===0){\n            return false;\n        }\n        for(var i=0,fn;fn=fns[i++];){\n            fn.apply(this,arguments);\n        }\n    };\n    /**\n     * 删除订阅\n     * @key {String} 类型\n     * @fn {Function} 回掉函数\n     * */\n    remove=function(key,fn){\n        var fns=clienlist[key];//取出该类型的对应的消息集合\n        if(!fns){//如果对应的key没有订阅直接返回\n            return false;\n        }\n        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅\n            fns && (fns.length=0);\n        }else{\n            for(var l=fns.length-1;l>=0;l--){//遍历回掉函数列表\n                if(fn===fns[l]){\n                    fns.splice(l,1);//删除订阅者的回掉\n                }\n            }\n        }\n    };\n    return{\n        addlisten:addlisten,\n        trigger:trigger,\n        remove:remove\n    }\n})();\n\n\n_Event.addlisten(\"jianbing\",function(d,all){\n    console.log(\"发布的消息来自：\"+d+\"，具体信息：\"+all);\n});\n_Event.addlisten(\"jianbing\",function(d,all){\n    console.log(\"发布的消息来自：\"+d+\"，具体信息：\"+all);\n})\n_Event.trigger(\"jianbing\",\"小小坤\",\"前端工程师，擅长JavaScript，喜欢结交更多的前端技术人员，欢迎喜欢技术的你加QQ群：198303871\")\n```\n\n', 5, '2020-8-19 10:29:49', '2020-10-26 15:34:14');
INSERT INTO `article` VALUES (22, 'promise then的用法', '```\nlet func = function() {\n    return new Promise((resolve, reject) => {\n        resolve(\'返回值\');\n    });\n};\n\nfunc().then(function(){return \'aa\'}).then(function(){return \'bb\'}).then(res=>console.log(res))    // \'bb\'\nfunc().then( \'aa\').then(res=>console.log(res))     // \'返回值\'\n```\n1. then回调方法，定义中讲过若then没有返回值，提供给下一个then使用的参数就是undefined，所以打印出来的是undefined;\n2. then执行后返回的并不是一个函数，在Promise规范中会自动忽略调当前then，所以会把func中的返回值供下一个then使用，输出了“返回值”\n', 1, '2020-8-19 15:07:03', '2020-10-3 01:03:27');
INSERT INTO `article` VALUES (23, '内存泄露', '内存泄露\n\n意外的全局变量: 无法被回收\n定时器: 未被正确关闭，导致所引用的外部变量无法被释放\n事件监听: 没有正确销毁 (低版本浏览器可能出现)\n闭包: 会导致父级中的变量无法被释放\ndom 引用: dom 元素被删除时，内存中的引用未被正确清空\n\n可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。\n', 0, '2020-8-19 15:45:10', '2020-8-19 15:45:10');
INSERT INTO `article` VALUES (24, 'script加载方式 defer async', '![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/284aec5bb7f16b3ef4e7482110c5ddbb_articlex.jpg)\n蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。\n```\n<script src=\"script.js\"></script>\n没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。\n<script async src=\"script.js\"></script>\n有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。\n<script defer src=\"myscript.js\"></script>\n有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成\n```\nasync 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行', 1, '2020-8-20 10:06:44', '2020-8-20 10:06:45');
INSERT INTO `article` VALUES (25, 'umi ssr 配置实践', '```\n	// nginx 配置文件\n    server {\n        listen       4443;\n        server_name  lms.com;\n\n        location / {\n						proxy_pass http://127.0.0.1:3000/;   #本地node服务 服务端的入口文件  umi-server.js\n        }\n				\n        location /dist/ {\n					root E:/umi-demo/umi-ssr/;     #静态文件目录\n				}\n				\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        location ^~/api/ {\n						rewrite ^/api/(.*)$ /$1 break;\n           	proxy_pass http://127.0.0.1:3333/;         #后端接口地址 前端代理  /api 开头\n        }\n    }\n		\n	//node 端部署，服务端的入口文件\n	const express = require(\'express\');\n	const app = express();\n	const port = 3000;\n	const domain = \'http://localhost\';\n	\n	// Express\n	app.use(async (req, res) => {\n		// 或者从 CDN 上下载到 server 端\n		// const serverPath = await downloadServerBundle(\'http://cdn.com/bar/umi.server.js\');\n		const render = require(\'../../../umi-ssr/dist/umi.server\');\n		res.setHeader(\'Content-Type\', \'text/html\');\n		const context = {};\n		const { html, error, rootContainer } = await render({\n			// 有需要可带上 query\n			path: req.url,\n			context,\n			// 可自定义 html 模板\n			// htmlTemplate: defaultHtml,\n			// 启用流式渲染\n			mode: \'stream\',\n			// html 片段静态标记（适用于静态站点生成）\n			// staticMarkup: false,\n			// 扩展 getInitialProps 在服务端渲染中的参数\n			// getInitialPropsCtx: {},\n			// manifest，正常情况下不需要\n		});\n		res.send(html);\n	})\n\n	app.listen(port, err => {\n		if (err) {\n			throw err;\n		}\n		console.log(`> Ready on port ${port}, ${domain}:${port}`);\n	});\n```', 4, '2020-9-8 16:41:16', '2020-12-19 16:48:56');
INSERT INTO `article` VALUES (26, 'for in for of forEach区别', 'let a = [\'a\',\'b\',\'c\'],b={title:\'cjj\',name:\'ming\'}\nfor in 可以循环数组和对象  // 0,1,2;title name\nfor of和foreach只可以循环数组 a b c; 不能循环', 2, '2020-9-10 17:54:52', '2020-10-3 00:56:52');
INSERT INTO `article` VALUES (27, 'umi ssr 原理和重要概念', '> import ReactDOMServer from \'react-dom/server\'\n* ReactDOMServer 类可以帮我们在服务端渲染组件 - 得到组件的 html 字符串。\n* ReactDOMServer.renderToString(element)\n我们可以用这个方法在服务端生成HTML字符串，然后将该字符串返回给浏览器端，完成页面内容的初始化，同时让搜索引擎可以抓取你的页面来达到优化SEO的目的。\n* ReactDOM.hydrate(element)\n当然也相应的提供了一个客户端渲染API - ReactDOM.hydrate()，从使用上来说和ReactDOM.render()没有差别。\n在浏览器端渲染时，该方法会最大限度的保留服务端使用renderToString()渲染的内容，同时添加事件绑定等交互。\n 浏览器端的组件渲染和服务端渲染的差别，服务端只是生成-html 字符串，也只会执行组件的componentWillMount方法。\n\n\n\n\n\n### 同构\n基于同构，浏览器和服务端可以运行同一份代码，服务端直出组件后，浏览器接管页面，然后剩下的工作由浏览器来完成。\n\n### 数据同构\n整体来说，组件的一些数据需要从接口异步获取后进行渲染，数据同构就是服务端和客户端能够使用同一个数据请求处理方法（一套代码），同一份数据进行组件的渲染。\n问题1：客户端和服务端组件渲染执行的声明周期不同，双端如何使用一套代码，代码如何组织呢？\n	为路由组件添加静态方法 \n	[源码loadPageGetInitialProps ](https://github.com/umijs/umi/tree/master/packages/preset-built-in/src/plugins/features/ssr/templates/renderServer/renderServer.tsx)\n#### 思路\n* 约定并为组件添加数据预取的静态方法 getInitialProps\n* 在服务端查找到当前路由对应的组件\n* 调用组件的数据预取方法得到数据\n* 将数据作为属性传入组件\n* 组件内render做相应的处理\n* 服务端直出组件\n* 浏览器接管页面，完成渲染\n问题2：真实开发中，浏览器的 fetch api 无法在node 端使用,如何统一呢？` axios, umi-request`\n\n### 数据脱水\nwindow.g_initialProps\n	[源码handleHTML](https://github.com/umijs/umi/tree/master/packages/preset-built-in/src/plugins/features/ssr/templates/utils.ts)\n我们在直出组件的时候同时将数据源也输出给浏览器，而这个过程就叫做数据脱水\n浏览器端也需要有相同的数据，使组件可以渲染出和服务端相同的结构，才能够通过双端节点对比。才不会被客户端的结构覆盖,从而使用服务端直出的 html 结构。\n我们可以直接把数据也吐给浏览器，将数据序列化后作为字符串直出到页面，这样在浏览器端就可以在组件渲染前很方便的得到数据\n\n### 数据注水\n[wrapInitialPropsFetch源码](https://github.com/umijs/umi/tree/master/packages/renderer-react/src/renderRoutes/renderRoutes.tsx)\n浏览器端在组件渲染前，得到初始化数据\n将数据作为属性传递给组件\n\n### 小结\n* 方法同构： 为组件声明getInitialProps静态方法，这是一个同构方法，用于双端的数据获取\n* 数据预取：在服务端通过路由匹配找到目标的组件，然后调用组件的数据预取方法得到数据\n* 将初始化数据作为属性传递给组件\n* 数据脱水：将数据序列化,和 html字符串 一起直出返回给浏览器端\n* 数据注水:浏览器端得到服务端直出的数据，也通过属性将数据传给组件\n* 如果初始化数据不存在，则可以在componentDidMount生命周期内请求一次数据\n\n### 流程图\n![](https://f6-ming.oss-cn-beijing.aliyuncs.com/image/16fe82eb96f4a852.jpg)\n\n### 服务端配置\n```\n	// nginx 配置文件\n    server {\n        listen       4443;\n        server_name  lms.com;\n\n        location / {\n						proxy_pass http://127.0.0.1:3000/;   #本地node服务 服务端的入口文件  umi-server.js\n        }\n				\n        location /dist/ {\n					root E:/umi-demo/umi-ssr/;     #静态文件目录\n				}\n				\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        location ^~/api/ {\n						rewrite ^/api/(.*)$ /$1 break;\n           	proxy_pass http://127.0.0.1:3333/;         #后端接口地址 前端代理  /api 开头\n        }\n    }\n		\n	//node 端部署，服务端的入口文件\n	const express = require(\'express\');\n	const app = express();\n	const port = 3000;\n	const domain = \'http://localhost\';\n	\n	// Express\n	app.use(async (req, res) => {\n		// 或者从 CDN 上下载到 server 端\n		// const serverPath = await downloadServerBundle(\'http://cdn.com/bar/umi.server.js\');\n		const render = require(\'../../../umi-ssr/dist/umi.server\');\n		res.setHeader(\'Content-Type\', \'text/html\');\n		const context = {};\n		const { html, error, rootContainer } = await render({\n			// 有需要可带上 query\n			path: req.url,\n			context,\n			// 可自定义 html 模板\n			// htmlTemplate: defaultHtml,\n			// 启用流式渲染\n			mode: \'stream\',\n			// html 片段静态标记（适用于静态站点生成）\n			// staticMarkup: false,\n			// 扩展 getInitialProps 在服务端渲染中的参数\n			// getInitialPropsCtx: {},\n			// manifest，正常情况下不需要\n		});\n		res.send(html);\n	})\n\n	app.listen(port, err => {\n		if (err) {\n			throw err;\n		}\n		console.log(`> Ready on port ${port}, ${domain}:${port}`);\n	});\n```\n', 14, '2020-9-15 11:47:25', '2020-10-29 08:52:31');
INSERT INTO `article` VALUES (28, 'nth-child用法', '/* 选择第n个，n位数字  */\n:nth-child(n)\n\n选择列表中的偶数标签\n:nth-child(2n)\n\n选择列表中的奇数标签\n:nth-child(2n-1)\n\n选择前几个元素\n/*【负方向范围】选择第1个到第6个 */\n:nth-child(-n+6){}\n\n从第几个开始选择\n/*【正方向范围】选择从第6个开始的，直到最后  */\n:nth-child(n+6){}\n\n两者结合使用，可以限制选择某一个范围\n/*【限制范围】选择第6个到第9个，取两者的交集【感谢小伙伴的纠正~】 */\n:nth-child(-n+9):nth-child(n+6){}\n\n选择列表中的倒数第n个标签 n为数字\n:nth-last-child(n)', 0, '2020-9-15 17:24:11', '2020-9-15 17:24:11');
INSERT INTO `article` VALUES (29, 'js模块', 'JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来\n在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。\nES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。\nexport命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。\nimport命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。\n> import {a} from \'./xxx.js\'\na = {}; // Syntax Error : \'a\' is read-only;\n\n由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n> // 报错\nimport { \'f\' + \'oo\' } from \'my_module\';\n// 报错\nlet module = \'my_module\';\nimport { foo } from module;\n// 报错\nif (x === 1) {\n  import { foo } from \'module1\';\n} else {\n  import { foo } from \'module2\';\n}\n\n目前阶段，通过 Babel 转码，CommonJS 模块的require命令和 ES6 模块的import命令，可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果\n\nexport default a;   或者    export {a};   \n分别对应\nimport a from module;  import { a } from module;', 2, '2020-9-21 14:39:11', '2020-10-3 00:58:17');
INSERT INTO `article` VALUES (30, 'event loop', '1. js在执行代码时，代码首先进入执行栈，代码中可能包含一些同步任务和异步任务。\n2. 同步任务立即执行，执行完出栈，over。\n3. 异步任务也就是常见的ajax请求、setTimeout等，代码调用到这些api的时候，WebAPIs来处理这些问题，执行栈继续执行。\n4. 异步任务有了运行结果时，（当ajax请求结果返回时），WebAPIs把对应的回调函数放到任务队列。\n5. 执行栈为空时来读取任务队列中的第一个函数，压入执行栈。\n\n步骤5不断重复，执行栈为空时，系统就去任务队列中拿第一个函数压入栈继续执行。这个过程不断重复，这就是事件循环（Event Loop）。\n', 1, '2020-9-25 09:43:43', '2020-10-3 01:12:05');
INSERT INTO `article` VALUES (31, 'simpread-从一道面试题谈谈对 EventLoop 的理解', '> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzUxNzk1MjQ0Ng==&mid=2247487053&idx=1&sn=d32c51e8eef74195ce2bb7615bd344b5&chksm=f991089ccee6818a9ca518b6878e35a0099f6d7fd030c769afadd5099d8e341e9d2a972bbd5a&mpshare=1&scene=1&srcid=0924FwjFFJ1D5XuflRWjKKVD&sharer_sharetime=1600922918662&sharer_shareid=c65ddbf569523f44545b22a63301140a&key=fdd054e9602c88a60dcf87f024958806f4eaa6712a8bd7af0be968d9232a548d4e684876a6cc767c90cf33aa7658e8042d7bd8dfab800222d136b8f2576d461ebf8a1f590f76488f18a80397c553a43a76d5a6609fa16ffbae5899f59d6f15d8f686b14b51d3daf121fab35b3571c8770d4e3517da16cbde2ccfd0b4a426291c&ascene=1&uin=MTczMTU2Mjc2MA%3D%3D&devicetype=Windows+7+x64&version=62090538&lang=zh_CN&exportkey=Adu4cn7Ct23hKjmSI0IvOyc%3D&pass_ticket=P2JJF%2FEJof6TsWVwlPZVqLyE1SMozmg8E%2FIb7cRyTYaAT0Uo0Mj7J5lQiiAELZF3&wx_header=0)\n\n  \n\n> 作者：前端自学驿站，原文链接：https://juejin.im/post/6868849475008331783\n\n前言\n--\n\n因为掘金改版之后对于字数有了一定的限制（亲测了下在12500字左右，所以看到标题还有几万字长文的标题一定是在唬你的?）文章美化排版之后字数超出了限制所以打算将后面的部分单独拎出来写, 这样也更好的写出相对比较深入的一点的内容, 对于`【前端体系】`这类文章内容一定是包括但不限于标题的，我会尽可能的拓展、深入、以写出高质量的好文章。\n\n> 在线卑微，如果觉得这篇文章对你有帮助的话欢迎大家点个赞?\n\n从一道题引出对Event Loop的思考\n--------------------\n\n对于Event Loop(事件轮询）所涉及的知识概念太多了，如果上来就讲一大堆概念性的东西太枯燥且从一开始就是按照我的思路来走的，所以我打算换一种方式来写这篇文章，你先按照你之前对于Event Loop(事件轮询)的理解来解这道题，我在后面写出我从Event Loop的理解思考这题的方式。两种不同的理解、想法、互相碰撞，我可能有理解不对的，你也可能有之前忽略的一些知识点，我们\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvZCJWbArD5t8LavGgCsG4YQt0nH9ibicUoKhEqWsorVmvsd2aFfaZwjpQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n不好意思放错了?，这张图\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBv6I1Nm66jGNPsiaQicpx2mo9QfqntoYeLeGticd91J3goCOTOoRyMeic0Rg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### 题目\n\n```\nconsole.log(\'script start\');  \n  \nsetTimeout(() => {  \n  console.log(\'北歌\');  \n}, 1 * 2000);  \n  \nPromise.resolve()  \n.then(function() {  \n  console.log(\'promise1\');  \n}).then(function() {  \n  console.log(\'promise2\');  \n});  \n  \n  \nasync function foo() {  \n  await bar()  \n  console.log(\'async1 end\')  \n}  \nfoo()  \n  \nasync function errorFunc () {  \n  try {  \n    await Promise.reject(\'error!!!\')  \n  } catch(e) {  \n    console.log(e)  \n  }  \n  console.log(\'async1\');  \n  return Promise.resolve(\'async1 success\')  \n}  \nerrorFunc().then(res => console.log(res))  \n  \nfunction bar() {  \n  console.log(\'async2 end\')   \n}  \n  \nconsole.log(\'script end\');  \n\n```\n\n好了，可以暂时不往下翻，先按照自己的理解来解下这道题。\n\n* * *\n\n* * *\n\n* * *\n\n-------------------------我是分割线-------------------------\n\n程序员成长指北 发起了一个读者讨论 写下你的答案or理解 精选讨论内容 参与讨论\n\n![](http://wx.qlogo.cn/mmhead/Q3auHgzwzM5DZaN6uo0bofgk13JajOaDxJeOicSwPE730enficZhpAaQ/132)\n\n卡罗\n\n我自己做这道题时得出结论：script start  ? async2 end ?  async1 ?  script end ?  promise1 ? async1 end ?  error!!!  ?  promise2  ? async1 success ? 北歌 但是实际上是： script start  ? async2 end  ?  script end ?  promise1 ? async1 end ?  error!!!  ? async1 ?   promise2  ? async1 success ? 北歌 学习了\n\n* * *\n\n* * *\n\n* * *\n\n相信这道题肯定难不倒大家，但是大家是按照什么样的方式来解出这道题的呢？其实这道题考察你了很多知识点，下面我将用我的理解来说说对这道题的思考。水平有限、有任何问题欢迎评论区指出。\n\nJS的运行机制\n-------\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvrGc3ARKFBY3jmkSAhdfrc9mhGLPD3enlA8KMWxJazpVrNjCQnrSOqw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n先来解释上图中出现的几个单词所要表达的含义。\n\nHeap(堆)、Stack(栈)、Queue(队列)、Event Loop(事件轮询)\n\n### 程序中的堆栈队列\n\n**Heap(堆)**\n\n堆， 是一种动态存储结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为**最大堆**，一种为**最小堆**，将根节点最大的堆叫做**最大堆**或**大根堆**，根节点最小的堆叫做**最小堆**或**小根堆**。堆是**线性数据结构**，相当于**一维数组**，有唯一后继。\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvbL3luDHNRSkFzpkET4JibQqmuK3D8an4XWtdshfbM7CjcQWyEXD42ibA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**栈（Stack）**\n\n栈在程序中的设定是限定仅在表尾进行插入或删除操作的线性表。栈是一种数据结构，它按照**后进先出**(`LIFO: last-in-first-out`)的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。栈是只能在某一端插入和删除的特殊线性表。\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvKkstskFTkqje9loYUGxEV4oeuCLUPbUvnO1aJM2mHwbtBOro5s4Mww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**队列（Queue**）\n\n队列特殊之处在于它只允许在表的前端（`front`）进行删除操作，而在表的后端（`rear`）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为**空队列**。\n\n队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为**先进先出**（`FIFO: first-in-first-out`）\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvReObVtNuxVeKVkiasM5ZXWpAgV5nBmniaHBbLSFoSckPksu5OJMZ0EQw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### js中的堆栈队列\n\n下面我解释下**JavaScript语言**中的堆、栈、队列。\n\n**堆**\n\n堆， 动态分配的内存，大小不定也不会自动释放，存放**引用类型**，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。可以简单理解为存储代码块。\n\n堆的作用：存储引用类型值的数据\n\n```\nlet obj = {  \n    name: \'北歌\'，  \n    puslic: \'前端自学驿站\'  \n}  \n  \nlet func = () => {  \n    console.log(\'hello world\')  \n}  \n\n```\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvAGrTPBkGZ88top3qpsrmz8M2cFXoC1BZsyyISiaibdickuKReIn0op1Jw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n**栈**\n\njs中的栈准确来将应该叫调用栈(EC Stack)，会自动分配内存空间，会自动释放，存放**基本类型**，简单的数据段，占据固定大小的空间。\n\n栈的作用：存储基本类型值，还有一个很要的作用。**提供代码执行的环境**\n\n**队列**\n\njs中的队列可以叫做**任务队列**或**异步队列**，任务队列里存放各种异步操作所注册的回调，里面分为两种任务类型，宏任务(`macroTask`)和微任务(`microTask`)。\n\n好，下面可以回到正题上来了。\n\n### 为什么会出现Event Loop\n\n总所周知JS是一门单线程的非阻塞脚本语言，Event Loop就是为了解决JS异步编程的一种解决方案。\n\n![](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH45RNOM0sYAw5Z625dLlcsBvHIgjZJP0WLgn807jLoaaNBlib8b0WeHE6JXJbBWyghLvwiaqXVLneAQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n### JS为什么是单线程语言，那它是怎么实现异步编程(非阻塞)运行的\n\n第一个问题：JavaScript的诞生就是为了处理浏览器网页的交互（DOM操作的处理、UI动画等),  设计成单线程的原因就是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果（两个线程修改了同一个DOM节点就会产生不必要的麻烦），这对于一种网页脚本语言来说这就太复杂了。\n\n第二个问题：JavaScript是单线程的但它所运行的宿主环境—浏览器是多线程，浏览器提供了各种线程供Event Loop调度来协调JS单线程运行时不会阻塞。\n\n### 小结\n\n先总结一波个人对于JS运行机制的理解：\n\n> 代码执行开启一个全局调用栈(主栈)提供代码运行的环境，在执行过程中同步任务的代码立即执行，遇到异步任务将异步的回调注册到任务队列中，等待同步代码执行完毕查看异步是否完成，如果完成将当前异步任务的回调拿到主栈中执行\n\n进程和线程\n-----\n\n进程：进程是 CPU 资源分配的最小单位(是能拥有资源和独立运行的最小单位)\n\n线程：线程是 CPU 调度的最小单位(线程是建立在进程的基础上的一次程序运行单位)\n\n对于进程和线程并没有确切统一的描述，可以简单的理解：\n\n> 比如一个应用程序: 如QQ、浏览器启动时会开启一个进程，而该进程可以有多个线程来进行资源调度和分配，达到运行程序的作用。\n> \n> 更通俗的话讲：打开QQ应用程序开启了进程来运行程序(QQ), 有多个线程来进行资源调度和分配(多个线程来分配打开QQ所占用的运存)，达到运行程序(QQ)的作用.\n\n用操作系统来作个例子：\n\n![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n> 线程依赖进程，一个进程可以有一个或者多个线程，但是线程只能是属于一个进程。\n\n### JS的单线程\n\njs的单线程指的是javaScript引擎只有一个线程\n\n单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。js 引擎执行异步代码而不用等待，是因有为有任务队列和事件轮询。\n\n*   任务队列：任务队列是一个先进先出的队列，它里面存放着各种任务回调。\n    \n*   事件轮询：事件轮询是指主线程重复从任务队列中取任务、执行任务的过程。\n    \n\n### 浏览器的多线程\n\n1.  GUI 渲染线程\n    \n\n*   绘制页面，解析 HTML、CSS，构建 DOM 树，布局和绘制等\n    \n*   页面重绘和回流\n    \n*   与 JS 引擎线程互斥，也就是所谓的 JS 执行阻塞页面更新\n    \n\n3.  JS 引擎线程\n    \n\n*   负责 JS 脚本代码的执行\n    \n*   负责准执行准备好待执行的事件，即定时器计数结束，或异步请求成功并正确返回的事件\n    \n*   与 GUI 渲染线程互斥，执行时间过长将阻塞页面的渲染\n    \n\n5.  事件触发线程\n    \n\n*   负责将准备好的事件交给 JS 引擎线程执行\n    \n*   多个事件加入任务队列的时候需要排队等待(JS 的单线程)\n    \n\n7.  定时器触发线程\n    \n\n*   负责执行异步的定时器类的事件，如 setTimeout、setInterval\n    \n*   定时器到时间之后把注册的回调加到任务队列的队尾\n    \n\n9.  HTTP 请求线程\n    \n\n*   负责执行异步请求\n    \n*   主线程执行代码遇到异步请求的时候会把函数交给该线程处理，当监听到状态变更事件，如果有回调函数，该线程会把回调函数加入到任务队列的队尾等待执行\n    \n\nEvent Loop\n----------\n\n呼，终于回到正题了！\n\n对于事件轮询上面其实已经解释的很清楚了：\n\n> 事件轮询就是解决javaScript单线程对于异步操作的一些缺陷，让 javaScript做到既是**单线程**，又绝对**不会阻塞**的核心机制，是用来协调各种事件、用户交互、脚本执行、UI 渲染、网络请求等的一种机制。\n\n### 浏览器中的Eveent Loop执行顺序\n\nProcessing model[1]规范定义了`Eveent Loop`的循环过程：\n\n一个Eveent Loop只要存在，就会不断执行下边的步骤：\n\n*   1.在tasks(任务)队列中选择最老的一个task,用户代理可以选择任何task队列，如果没有可选的任务，则跳到下边的microtasks步骤。\n    \n*   2.将上边选择的task设置为正在运行的task[2]。\n    \n*   3.Run: 运行被选择的task。\n    \n*   4.将Eveent Loop的currently running task[3]变为null。\n    \n*   5.从task队列里移除前边运行的task。\n    \n*   6.Microtasks: 执行microtasks任务检查点[4]。（也就是执行microtasks队列里的任务）\n    \n*   7.更新渲染（Update the rendering）：可以简单理解为浏览器渲染...\n    \n*   8.如果这是一个worker event loop，但是没有任务在task队列中，并且WorkerGlobalScope[5]对象的closing标识为true，则销毁Eveent Loop，中止这些步骤，然后进行定义在Web workers[6]章节的run a worker[7]。\n    \n*   9.返回到第一步。\n    \n\nEveent Loopp会不断循环上面的步骤，概括说来：\n\n*   `Eveent Loop`会不断循环的去取`tasks`队列的中最老的一个task(可以理解为宏任务）推入栈中执行，并在当次循环里依次执行并清空`microtask`队列里的任务。\n    \n*   执行完`microtask`队列里的任务，有**可能**会渲染更新。（浏览器很聪明，在一帧以内的多次dom变动浏览器不会立即响应，而是会积攒变动以最高60HZ(大约16.7ms每帧)的频率更新视图）\n    \n\n### 宏任务和微任务优先问题\n\n> 在任务对列(queue)中注册的异步回调又分为两种类型，宏任务和微任务。我们为了方便理解可以认为在任务队列中有宏任务队列和微任务队列。宏任务队列有多个，微任务只有一个\n\n*   宏任务(macro Task)\n    \n\n*   script(整体代码)\n    \n*   setTimeout/setInterval\n    \n*   setImmediate(Node环境)\n    \n*   UI 渲染\n    \n*   requestAnimationFrame\n    \n*   ....\n    \n\n*   微任务(micro Task)\n    \n\n*   Promise的then()、catch()、finally()里面的回调\n    \n*   process.nextTick(Node 环境）\n    \n*   ...\n    \n\n个人理解的执行顺序：\n\n1.  代码从开始执行调用一个全局执行栈，script标签作为宏任务执行\n    \n2.  执行过程中同步代码立即执行，异步代码放到任务队列中，任务队列存放有两种类型的异步任务，宏任务队列，微任务队列。\n    \n3.  同步代码执行完毕也就意味着第一个宏任务执行完毕(script)\n    \n\n*   1、先查看任务队列中的微任务队列是否存在宏任务执行过程中所产生的微任务\n    \n    1-1、有的话就将微任务队列中的所有微任务清空\n    \n    2-2、微任务执行过程中所产生的微任务放到微任务队列中，在此次执行中一并清空\n    \n*   2、如果没有再看看宏任务队列中有没有宏任务，有的话执行，没有的话事件轮询第一波结束\n    \n    2-1、执行过程中所产生的微任务放到微任务队列\n    \n    2-2、完成宏任务之后执行清空微任务队列的代码\n    \n\n![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n> 所以是宏任务优先，在宏任务执行完毕之后才会来一次性清空任务队列中的所有微任务。\n\n### 解题分析过程\n\n将最开始的那道题搬下来\n\n```\n// => 代码一执行就开始执行了一个宏任务-宏0  \nconsole.log(\'script start\');   \n  \nsetTimeout(() => { // 宏 1  \n  console.log(\'北歌\');  \n}, 1 * 2000);  \n  \nPromise.resolve()  \n    .then(function() { // 微1-1  \n      console.log(\'promise1\');  \n    })  \n    .then(function() { // 微1-4 => 这个then中的会等待上一个then执行完成之后得到其状态才会向Queue注册状态对应的回调，假设上一个then中主动抛错且没有捕获，那就注册的是这个then中的第二个回调了。  \n      console.log(\'promise2\');   \n    });  \n  \n  \nasync function foo() {  \n  await bar() // => await(promise的语法糖)，会异步等待获取其返回值  \n  // => 后面的代码可以理解为放到异步队列微任务中。 这里可以保留疑问后面会详细说  \n  console.log(\'async1 end\') // 微1-2  \n}  \nfoo()  \n  \nfunction bar() {  \n  console.log(\'async2 end\')   \n}  \n  \nasync function errorFunc () {  \n  try {  \n    await Promise.reject(\'error!!!\')  \n  } catch(e) {  \n      // => 从这后面开始所有的代码可以理解为放到异步队列微任务中  \n    console.log(e)  // 微1-3  \n  }  \n  console.log(\'async1\');  \n  return Promise.resolve(\'async1 success\')  \n}  \nerrorFunc().then(res => console.log(res)) // 微1-5  \n  \nconsole.log(\'script end\');  \n\n```\n\n上面代码对于Promise的用法我就不多讲了, 在后面我会写关于Promise源码解析的文章。\n\n注意一点就是Promise.then().then()，在注册异步任务的时候，第二个then中的回调是依赖第一个then中回调的结果的，如果执行没有异常才会在该异步任务执行完毕之后注册状态对应的回调\n\n#### 第一次执行\n\n全局一个宏任务执行, 输出同步代码。挂载宏1、微1-1、微1-2、微1-3、微1-4。1-表示属于第一次轮询\n\n```\nrun: script start、 async2 end、script end  \n\n```\n\n#### 第二次执行\n\n同步代码执行完毕，开始执行异步任务中的微任务队列中的代码。\n\n**微任务队列：只有一个队列且会在当前轮询一次清空**\n\n```\nrun:  \n 执行微1-1: promise1  \n 执行微1-2: async1 end  \n 执行微1-3: error!!!、async1 。当前异步回调执行完毕才Promise.resolve(\'async1 success\')，然后注册then()中的成功的回调-微1-5  \n 执行微1-4: promise2  \n    执行刚刚注册的微1-5: async1 success  \n\n```\n\n**到这第一波轮询结束**\n\n#### 第三次执行\n\n开启第二波轮询：执行宏1\n\n```\nrun: \'北歌\'  \n\n```\n\n到这。整个轮询结束。\n\n> 其实相对难以理解的也就是微任务，对于微任务也就是上面说的只有一个队列会在**此次**轮询中一次清空(包括**此次**执行过程中所产生的微任务)。\n\n举个栗子?\n\n你去堂食排队打菜，原本你计划今天只吃两个菜(微任务队列中只注册了两个回调)，在打菜的过程中你看到你最喜欢吃的红烧肉(微任务执行的过程中遇到的新的微任务)，你肯定得再加个菜(将微任务加入到微任务队列)\n\n打怪进阶\n----\n\n通过上面的讲解现在可以刷几道题来看看自己撑握的怎么样了。\n\n### 黄金题\n\n```\nconsole.log(\'1\');  \n  \nsetTimeout(() => {  \n  console.log(\'2\');  \n  Promise.resolve().then(() => {  \n    console.log(\'3\');  \n  })  \n  new Promise((resolve) => {  \n    console.log(\'4\');  \n    resolve();  \n  }).then(() => {  \n    console.log(\'5\')  \n  })  \n})  \n  \nPromise.reject().then(() => {  \n  console.log(\'13\');  \n}, () => {  \n  console.log(\'12\');  \n})  \n  \nnew Promise((resolve) => {  \n  console.log(\'7\');  \n  resolve();  \n}).then(() => {  \n  console.log(\'8\')  \n})  \n  \nsetTimeout(() => {  \n  console.log(\'9\');  \n  Promise.resolve().then(() => {  \n    console.log(\'10\');  \n  })  \n  new Promise((resolve) => {  \n    console.log(\'11\');  \n    resolve();  \n  }).then(() => {  \n    console.log(\'12\')  \n  })  \n})  \n\n```\n\n### 砖石题\n\n```\nnew Promise((resolve, reject) => {  \n    console.log(1)  \n    resolve()  \n  })  \n  .then(() => {  \n    console.log(2)  \n    new Promise((resolve, reject) => {  \n        console.log(3)  \n        setTimeout(() => {  \n          reject();  \n        }, 3 * 1000);  \n        resolve()  \n    })  \n      .then(() => {  \n        console.log(4)  \n        new Promise((resolve, reject) => {  \n            console.log(5)  \n            resolve();  \n          })  \n          .then(() => {  \n            console.log(7)  \n          })  \n          .then(() => {  \n            console.log(9)  \n          })  \n      })  \n      .then(() => {  \n        console.log(8)  \n      })  \n  })  \n  .then(() => {  \n    console.log(6)  \n  })  \n\n```\n\n### 王者题\n\n```\nPromise.resolve()  \n  .then(() => {  \n    console.log(\'promise1\');  \n    return new Promise((resolve, reject) => {  \n        setTimeout(() => {  \n          console.log(\'timer2\')  \n          resolve()  \n        }, 0)  \n    })  \n      .then(async () => {  \n        await foo();  \n        return new Error(\'error1\')  \n      })  \n      .then((ret) => {  \n        setTimeout(() => {  \n          console.log(ret);  \n          Promise.resolve()  \n          .then(() => {  \n            return new Error(\'error!!!\')  \n          })  \n          .then(res => {  \n            console.log(\"then: \", res)  \n          })  \n          .catch(err => {  \n            console.log(\"catch: \", err)  \n          })  \n        }, 1 * 3000)  \n      }, err => {  \n        console.log(err);  \n      })  \n      .finally((res) => {  \n        console.log(res);  \n        throw new Error(\'error2\')  \n      })  \n      .then((res) => {  \n        console.log(res);  \n      }, err => {  \n        console.log(err);  \n      })  \n  })  \n  .then(() => {  \n    console.log(\'promise2\');  \n  })  \n  \nfunction foo() {  \n  setTimeout(() => {   \n    console.log(\'async1\');  \n  }, 2 * 1000);  \n}  \n  \nsetTimeout(() => {  \n  console.log(\'timer1\')  \n  Promise.resolve()  \n    .then(() => {  \n      console.log(\'promise3\')  \n    })  \n}, 0)  \n  \nconsole.log(\'start\');  \n\n```\n\n### 荣耀王者\n\n下面让我们来一起做最后这道题。\n\n```\nasync function async1() {  \n  console.log(\'async1 start\');  \n  new Promise((resolve, reject) => {  \n    try {  \n      throw new Error(\'error1\')  \n    } catch(e) {  \n      console.log(e);  \n    }  \n    setTimeout(() => { // 宏3  \n      resolve(\'promise4\')  \n    }, 3 * 1000);  \n  })  \n    .then((res) => { // 微3-1  \n      console.log(res);  \n    }, err => {  \n      console.log(err);  \n    })  \n    .finally(res => { // 微3-2 // TODO注3  \n      console.log(res);  \n    })  \n  console.log(await async2()); // TODO-注1  \n  console.log(\'async1 end\'); // 微1-1 // TODO-注2  \n}  \n  \nfunction async2() {  \n  console.log(\'async2\');  \n  return new Promise((resolve) => {  \n    setTimeout(() => { // 宏4  \n      resolve(2)  \n    }, 1 * 3000);  \n  })  \n}  \n  \nconsole.log(\'script start\');  \n  \nsetTimeout(() => { // 宏2  \n  console.log(\'setTimeout\');  \n}, 0)  \n  \nasync1();  \n  \nnew Promise((resolve) => {  \n  console.log(\'promise1\');  \n  resolve();  \n})  \n  .then(() => { // 微1-2  \n    console.log(\'promise2\');  \n    return new Promise((resolve) => {  \n      resolve()  \n    })  \n      .then(() => { // 微1-3  \n        console.log(\'then 1-1\')  \n      })  \n  })  \n  .then(() => { // 微1-4  \n    console.log(\'promise3\');  \n  })  \n  \n  \nconsole.log(\'script end\');  \n\n```\n\n#### 规定\n\n现在为了方便大家理解，请记住一下规定：\n\n*   分析以每次轮询做为分析，同步代码块是直接输出结果的\n    \n*   异步任务代码块中，红色表示宏任务，绿色表示微任务\n    \n*   `微1-`表示第一次轮询中的微任务队列中的所有微任务，`微2-`表示第二次，以此类推\n    \n\n#### 第一次轮询\n\nscript标签(宏0)执行\n\n输出同步代码：\n\n```\nscript start -> async1 start -> error1 -> async2 -> promise1 -> script end  \n\n```\n\n挂载异步任务:\n\n```\n-() => { // 宏2  \n-  console.log(\'setTimeout\');  \n-}  \n  \n-() => { // 宏3  \n-  resolve(\'promise4\')  \n-}  \n  \n-() => { // 宏4  \n-  resolve(2)  \n-}  \n  \n  \n+() => { // 微1-1  \n+  console.log(\'promise2\');  \n+  return new Promise((resolve) => {  \n+  resolve()  \n+}  \n\n```\n\n同步代码完毕的同时第一个宏任务也执行完毕，开始清空异步任务中的微任务队列：\n\n```\n微1-1: promise2 -> 微1-2: then 1-1 -> 微1-3: promise3  \n\n```\n\n执行微任务中所产生新的微任务, 放到微任务队列中，该微任务也会在此次轮询中被清空:\n\n```\n+() => { // 微1-2  \n+  console.log(\'then 1-1\')  \n+}  \n  \n+() => { // 微1-3  \n+  console.log(\'promise3\');  \n+}  \n\n```\n\n执行微任务过程中所产生的宏任务放到新宏任务队列中：\n\n```\n本次微任务执行没有产生新的宏任务  \n\n```\n\n**注1**\n\n> 这里得说一下，很多人认为await将代码同步化的意思，其实await是Promise的语法糖，内部的实现也是依靠Promise, 其诞生也就是为了优化promise的then链写法，用同步的方式编写异步代码，让代码看起来更简洁明了 await的真实意思是 async wait(异步等待的意思)await表达式相当于调用后面返回promise的then方法，异步（等待）获取其返回值。即 await<==>promise.then\n> \n> 这里的async2函数返回的Promise中开启了一个宏任务，await异步等待需要等待宏任务执行才能获取其返回值，也就是说宏任务不执行await表达式就压根不能调用Promise的then方法\n\n**注2**\n\n> 前面说过await表达式后面的代码可以简单理解为放入到微任务中，但是前面await 表达式压根就没有获取异步等待的结果这后面的代码从跳出当前执行栈后就压根没有挂载到异步任务中，有些教程说的await 表达式后面的代码可以看成微任务队列的第一个这种说法是错误的！\n\n此次轮询结束输出结果有：\n\n```\nscript start -> async1 start -> error1 -> async2 -> promise1 -> script end  \n微1-1: promise2 -> 微1-2: then 1-1 -> 微1-3: promise3  \n\n```\n\n#### 第二次轮询\n\n上面第一波轮询结束，开启第二波轮询\n\n执行第二个宏任务队列(宏任务队列只存放一个宏任务)：\n\n```\n宏2：setTimeout  \n\n```\n\n宏任务执行完毕没有产生新的微任务，也没有产生新的宏任务。第二次轮询结束\n\n此次轮询结束输出结果有：\n\n```\n宏2：setTimeout  \n\n```\n\n#### 第三次轮询\n\n执行第三个宏任务队列(宏任务队列只存放一个宏任务)：\n\n```\n宏任务本身没有输出啥，不过确定了下Promise的状态并传递了个\'promise4\'给下一个then中的成功回调  \n\n```\n\n宏任务执行过程中产生的新的微任务放到微任务队列:\n\n```\n+(res) => { // 微3-1  \n+  console.log(res);  \n+}  \n\n```\n\n宏任务执行完毕开始清空异步任务中的微任务队列：\n\n```\n微3-1: promise4 -> 微3-2: undefined  \n\n```\n\n执行微任务中所产生新的微任务, 放到微任务队列中，该微任务也会在此次轮询中被清空:\n\n```\n+res => { // 微3-2 // TODO注3  \n+  console.log(res);  \n+}  \n\n```\n\n执行微任务过程中所产生的宏任务放到新宏任务队列中：\n\n```\n本次微任务执行没有产生新的宏任务  \n\n```\n\n此次轮询结束输出结果有：\n\n```\n微3-1: promise4 -> 微3-2: undefined  \n\n```\n\n**注3**\n\n> 前面说过promise.finally()也是微任务，finally可以理解为不管promise的状态是成功或失败都要执行我。但是我不接受任何结果。因此finally接受不到返回值res为undefined\n\n#### 第四次轮询\n\n执行第四个宏任务队列(宏任务队列只存放一个宏任务)：\n\n```\n宏任务本身没有输出啥，不过确定了下Promise的状态并传递了个2给下一个then中的成功回调  \n\n```\n\n宏任务执行过程中产生的新的微任务放到微任务队列:\n\n上面说过await => Promise.then(), 上面宏任务执行完毕确定了promise状态可以去获取异步等待的结果。相当于这样：Promise.then((res) => {return res})而await表达式后面的代码相当于在**异步等待获取结果后**放到微任务队列中相当于这样：Promise.then((res) => {return res}).finally(() => {}), 只有在await 表达式前面获取到结果后才会在代码挂在到异步队列中\n\n可以做个实验将上面异步等待定时器的值设定为更长时间，这个时候await表达式后面的代码是不为响应的，只有获取到了异步等待的结果，才会响应。\n\n```\n+(res) => {return res} // 微4-1  \n  \n+() => {async1 end} // 微4-2  \n\n```\n\n宏任务执行完毕开始清空异步任务中的微任务队列：\n\n```\n微4-1: 2 -> 微4-2: async1 end  \n\n```\n\n执行微任务中所产生新的微任务, 放到微任务队列中，该微任务也会在此次轮询中被清空:\n\n```\n本次微任务执行没有产生新的微任务  \n\n```\n\n执行微任务过程中所产生的宏任务放到新宏任务队列中：\n\n```\n本次微任务执行没有产生新的宏任务  \n\n```\n\n此次轮询结束输出结果有：\n\n```\n微4-1: 2 -> 微4-2: async1 end  \n\n```\n\n#### 所有轮询完毕之后的完整结果\n\n```\nscript start -> async1 start -> error1 -> async2 -> promise1 -> script end  \n微1-1: promise2 -> 微1-2: then 1-1 -> 微1-3: promise3  \n  \n宏2：setTimeout  \n  \n微3-1: promise4 -> 微3-2: undefined  \n  \n微4-1: 2 -> 微4-2: async1 end  \n\n```\n\n如果你四道题全对的话，那么恭喜你。\n\n![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n写在最后\n====\n\n对于【前端体系】这系列的文章我是抱着很认真，很想写好的心态的，但毕竟我还是前端小白&写作新人，如果文章中有那块写的不太好或有问题欢迎大家指出，我也会在后面的文章不停修改。也希望自己进步的同时能跟你们一起成长。喜欢我文章的朋友们也可以关注一下\n\n我会很感激第一批关注我的人。**此时，年轻的我和你，轻装上阵；而后，富裕的你和我，满载而归。**\n\n系列文章\n----\n\n【前端体系】从地基开始打造一座万丈高楼[8]\n\n参考文章\n----\n\n深入理解 JavaScript Event Loop[9]\n\n  \n\n### 参考资料\n\n[1]\n\nProcessing model: _https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model_\n\n[2]\n\n正在运行的task: _https://html.spec.whatwg.org/multipage/webappapis.html#currently-running-task_\n\n[3]\n\ncurrently running task: _https://html.spec.whatwg.org/multipage/webappapis.html#currently-running-task_\n\n[4]\n\nmicrotasks任务检查点: _https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint_\n\n[5]\n\nWorkerGlobalScope: _https://html.spec.whatwg.org/multipage/workers.html#workerglobalscope_\n\n[6]\n\nWeb workers: _https://html.spec.whatwg.org/multipage/workers.html#workers_\n\n[7]\n\nrun a worker: _https://html.spec.whatwg.org/multipage/workers.html#run-a-worker_\n\n[8]\n\n【前端体系】从地基开始打造一座万丈高楼: _https://juejin.im/post/6867784542338416648#comment_\n\n[9]\n\n深入理解 JavaScript Event Loop: _https://zhuanlan.zhihu.com/p/34229323_\n\n交流讨论\n----\n\n```\n\n\n```\n\n\n❤️爱心三连击\n-------\n\n1.看到这里了就点个在看支持下吧，你的**「点赞，**在看**」**是我创作的动力。\n\n2.关注公众号`程序员成长指北`，回复「1」加入Node进阶交流群！「在这里有好多 Node 开发者，会讨论 Node 知识，互相学习」！\n\n3.也可添加微信【**ikoala520**】，一起成长。  \n\n![](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)\n\n  \n\n\n\n```\n\n**“在看转发”是最大的支持**\n\n\n```', 2, '2020-9-25 09:47:56', '2020-10-3 01:07:00');
INSERT INTO `article` VALUES (32, 'setState异步还是同步', '在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState是\"异步\"的；\nisBatchingUpdates是该事务的一个标志，如果为true，表示react正在一个更新组件的事务流中，\n* 如果没有在事务流中，调用batchedUpdates方法进入更新流程，进入流程后，会将isBatchingUpdates设置为true。\n* 否则，将需更新的组件放入dirtyComponents中，也很好理解，先将需更新的组件存起来，稍后更新。这就解释了在componentDidMount中调用setState并不会立即更新state，因为正处于一个更新流程中，isBatchingUpdates为true，所以只会放入dirtyComponents中等待稍后更新。\n\n原因: 因为在setState的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入dirtyComponents队列中等待执行；否则，开始执行batchedUpdates队列更新；\n在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中\n而componentDidUpdate是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；\n在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；', 4, '2020-10-20 18:06:08', '2020-10-21 08:15:30');
INSERT INTO `article` VALUES (33, '常用webpack配置', '```\nvar webpack = require(\'webpack\');\nvar path = require(\'path\');\nvar HtmlWebpackPlugin = require(\'html-webpack-plugin\')\nvar CleanWebpackPlugin = require(\'clean-webpack-plugin\')\nvar ExtractTextPlugin = require(\'extract-text-webpack-plugin\')\nvar OptimizeCSSPlugin = require(\'optimize-css-assets-webpack-plugin\')\n\nconst VENOR = [\"faker\",\n  \"lodash\",\n  \"react\",\n  \"react-dom\",\n  \"react-input-range\",\n  \"react-redux\",\n  \"redux\",\n  \"redux-form\",\n  \"redux-thunk\",\n  \"react-router\"\n]\n\nmodule.exports = {\n  entry: {\n    bundle: \'./src/index.js\',\n    vendor: VENOR\n  },\n  // 如果想修改 webpack-dev-server 配置，在这个对象里面修改\n  devServer: {\n    port: 8081\n  },\n  output: {\n    path: path.join(__dirname, \'dist\'),\n    filename: \'[name].[chunkhash].js\'\n  },\n  module: {\n    rules: [{\n        test: /\\.js$/,\n        use: \'babel-loader\'\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        use: [{\n            loader: \'url-loader\',\n            options: {\n                limit: 10000,\n                name: \'images/[name].[hash:7].[ext]\'\n            }\n        }]\n    },\n    {\n        test: /\\.css$/,\n        loader: ExtractTextPlugin.extract({\n            fallback: \'style-loader\',\n            use: [{\n            // 这边其实还可以使用 postcss 先处理下 CSS 代码\n                loader: \'css-loader\'\n            }]\n        })\n    },\n    ]\n  },\n  plugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n      name: [\'vendor\', \'manifest\'],\n      minChunks: Infinity\n    }),\n    new CleanWebpackPlugin([\'dist/*.js\'], {\n      verbose: true,\n      dry: false\n    }),\n    new HtmlWebpackPlugin({\n      template: \'index.html\'\n    }),\n    // 生成全局变量\n    new webpack.DefinePlugin({\n      \"process.env.NODE_ENV\": JSON.stringify(\"process.env.NODE_ENV\")\n    }),\n    // 分离 CSS 代码（文件形式）而不是sytle标签插入html\n    new ExtractTextPlugin(\"css/[name].[contenthash].css\"),\n    // 压缩提取出的 CSS，并解决ExtractTextPlugin分离出的 JS 重复问题\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: {\n        safe: true\n      }\n    }),\n    // 压缩 JS 代码\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    })\n  ]\n};\n\n\n```', 0, '2020-10-21 19:40:17', '2020-10-21 19:40:17');
INSERT INTO `article` VALUES (34, 'react-router原理', '让我们回想下我们看完基础用法梳理的流程：\n\n使用<BrowserRouter>创建一个专门的history对象，并注册监听事件。\n使用<Route>匹配的path，并渲染匹配的组件。\n使用<Link>创建一个链接跳转到你想要渲染的组件。\n\n结合源码我们再分析下具体实现\n\n使用BrowserRouterrender一个Router时创建了一个全局的history对象，并通过props传递给了Router，而在Router中设置了一个监听函数，使用的是history库的listen，触发的回调里面进行了setState向下传递 nextContext。\n当点击页面的Link是，其实是点击的a标签，只不过使用了 preventDefault 阻止 a 标签的页面跳转；通过给a标签添加点击事件去执行 hitsory.push(to)。\n路由改变是会触发 Router 的 setState 的，在 Router 那章有写道：每次路由变化 -> 触发顶层 Router 的监听事件 -> Router 触发 setState -> 向下传递新的 nextContext（nextContext 中含有最新的 location）。\nRoute 接受新的 nextContext 通过 matchPath 函数来判断 path 是否与 location 匹配，如果匹配则渲染，不匹配则不渲染。\n', 1, '2020-10-27 14:40:08', '2020-10-27 14:40:10');
INSERT INTO `article` VALUES (35, '常用的函数，柯力化', '```\nvar curring = function(){\n    var arg = []\n    return function cb(){\n        if(arguments.length === 0) return arg\n        arg.push.apply(arg,arguments)\n        return cb\n    }\n}\n```', 0, '2020-11-10 16:00:48', '2020-11-10 16:00:48');
INSERT INTO `article` VALUES (36, 'redux代码模拟功能实现', '```\n// store.js\nexport const createStore = (reducer) => {    \n    let currentState = {}    \n    let observers = []             //观察者队列    \n    function getState() {        \n        return currentState    \n    }    \n    function dispatch(action) {        \n        currentState = reducer(currentState, action)       \n        observers.forEach(fn => fn())    \n    }    \n    function subscribe(fn) {        \n        observers.push(fn)    \n    }    \n    dispatch({ type: \'@@REDUX_INIT\' }) //初始化store数据    \n    return { getState, subscribe, dispatch }\n}\n\n\n//reducer.js\nconst initialState = {    \n    count: 0\n}\n\nexport function reducer(state = initialState, action) {    \n    switch(action.type) {      \n        case \'plus\':        \n        return {            \n            ...state,            \n            count: state.count + 1        \n        }      \n        case \'subtract\':        \n        return {            \n            ...state,            \n            count: state.count - 1        \n        }      \n        default:        \n        return initialState    \n    }\n}\n\n//react-redux.js\nimport React from \'react\'\nimport PropTypes from \'prop-types\'\nexport class Provider extends React.Component {  \n    // 需要声明静态属性childContextTypes来指定context对象的属性,是context的固定写法  \n    static childContextTypes = {    \n        store: PropTypes.object  \n    }  \n\n    // 实现getChildContext方法,返回context对象,也是固定写法  \n    getChildContext() {    \n        return { store: this.store }  \n    }  \n\n    constructor(props, context) {    \n        super(props, context)    \n        this.store = props.store  \n    }  \n\n    // 渲染被Provider包裹的组件  \n    render() {    \n        return this.props.children  \n    }\n}\n\nexport function connect(mapStateToProps, mapDispatchToProps) {    \n    return function(Component) {      \n    class Connect extends React.Component {        \n        componentDidMount() {          //从context获取store并订阅更新          \n            this.context.store.subscribe(this.handleStoreChange.bind(this));        \n        }        \n        handleStoreChange() {          \n            // 触发更新          \n            // 触发的方法有多种,这里为了简洁起见,直接forceUpdate强制更新,读者也可以通过setState来触发子组件更新          \n            this.forceUpdate()        \n        }        \n        render() {          \n            return (            \n                <Component              \n                    // 传入该组件的props,需要由connect这个高阶组件原样传回原组件              \n                    { ...this.props }              \n                    // 根据mapStateToProps把state挂到this.props上              \n                    { ...mapStateToProps(this.context.store.getState()) }               \n                    // 根据mapDispatchToProps把dispatch(action)挂到this.props上              \n                    { ...mapDispatchToProps(this.context.store.dispatch) }             \n                />          \n            )        \n        }      \n    }      \n\n    //接收context的固定写法      \n    Connect.contextTypes = {        \n        store: PropTypes.object      \n    }      \n    return Connect    \n    }\n}  \n\n```', 2, '2020-11-12 16:10:04', '2020-12-7 18:06:48');
INSERT INTO `article` VALUES (37, 'docker一些流程', 'docker build -f deployment/docker/Dockerfile -t myblog:1.1 .      // -f 指定Dockerfile路径， -t 镜像名称和版本   注意后面路径\ndocker tag ff0630c5aefb lm18238818077/myblog:v1.0     //为了解决push权限问题，需要更改一下\ndocker push lm18238818077/myblog:v1.0\n', 0, '2020-12-7 18:16:40', '2020-12-7 18:16:40');
